<!DOCTYPE html>
<!--
Обязательное задание.

Выполнить все задачи в теге script. Комментарии, в которых написаны задачи, не
стирать, код с решением задачи пишем под комментарием.
-->
<style>
  .error {
    border: 1px solid red;
    outline-color: red;
  }

  .form-control {
    padding: 10px;
  }

  .myElem {
    animation: 0.8s ease-in-out 0s normal none 2 running trambling-animation;
  }
  @keyframes trambling-animation {
    0%,
    50%,
    100% {
      transform: rotate(0deg);
    }
    10%,
    30% {
      transform: rotate(-5deg);
    }
    20%,
    40% {
      transform: rotate(5deg);
    }
  }
</style>
<input id="from" type="text" />
В инпуте написано: <span></span>

<br />

<button class="messageBtn">Показать блок</button>
<div class="message">Привет :)</div>

<br />

<form class="myForm">
  <label>
    Первый инпут:
    <input class="form-control" type="text" />
  </label>
  <br />
  <br />
  <label>
    Второй инпут:
    <select class="form-control">
      <option value=""></option>
      <option value="1">Один</option>
      <option value="2">Два</option>
    </select>
  </label>
  <br />
  <br />
  <button>Отправить</button>
</form>

<script>
  "use strict";

  /*
  1. При изменении значения в input с id="from", значение содержащееся в нем
  должно моментально отображаться в span. То есть при печати в input'е тег span
  также должен меняться.
  */
  const getIdInput = document.querySelector("#from");
  const getSpan = document.querySelector("span");
  getIdInput.addEventListener("input", (e) => {
    getSpan.textContent = e.target.value;
  });

  /*
  2. При клике на кнопку с классом messageBtn необходимо элементу с классом
  message:
  1) добавить два класса: animate_animated и animate_fadeInLeftBig
  2) поставить данному элементу стиль visibility в значение 'visible'.
  */

  const getMessageBtn = document.querySelector(".messageBtn");
  const getMessage = document.querySelector(".message");
  getMessageBtn.addEventListener("click", () => {
    getMessage.classList.add("animate_animated", "animate_fadeInLeftBig");
    if (getMessage.style.visibility == "hidden") {
      getMessage.style.visibility = "visible";
    } else {
      getMessage.style.visibility = "hidden";
    }
  });

  /*
  3. Необходимо при отправке формы проверить, заполнены ли все поля в этой
  форме. Если какое-либо поле не заполнено, форма не должна отправляться, также
  должны быть подсвечены незаполненные поля (необходимо поставить класс error
  незаполненным полям).
  Как только пользователь начинает заполнять какое-либо поле, необходимо,
  при вводе в данное поле, произвести проверку:
  Если поле пустое, необходимо данное поле подсветить (поставить класс error
  данному полю).
  Если поле было чем-либо заполнено, подсветку (класс error) необходимо убрать.

  Доп. задание: добавить анимации в случае, если ошибка (error)
  */
/*
  const getMyForm = document.querySelector(".myForm");
  const findInput = document.querySelectorAll(".form-control");
  const findInputArray = Array.prototype.slice.call(findInput);

  
    findInputArray[0].addEventListener("mouseout", () => {
      const label1 = findInput[0].value;      
      if (label1 == '') {findInputArray[0].classList.add("error");}
      else {findInputArray[0].classList.remove("error")};
    });

    findInputArray[1].addEventListener("mouseout", () => {
      const label2 = findInput[1].options.selectedIndex;
      if (label2 == 0) {findInputArray[1].classList.add("error");}
      else {findInputArray[1].classList.remove("error")};
    });
*/


const formEl = document.querySelector(".myForm");
      const buttonEl = formEl.querySelector("button");
      const inputEls = formEl.querySelectorAll(".form-control");

      buttonEl.addEventListener("click", function (e) {
        inputEls.forEach((element) => {
          if (!element.value) {
            element.classList.add("error");
            e.preventDefault();
          }
        });
      });

      inputEls.forEach((element) => {
        element.addEventListener("input", function (e) {
          e.target.classList.remove("error");
        });
      });

/*
  findInputArray.forEach((element) => {
    element.addEventListener("mouseout", () => {
      const label1 = findInput[1].options.selectedIndex;
      const label2 = findInput[0].value;

      if (label1 == 0 && element.tagName == "SELECT") {
        element.classList.add("error");
      } else {
        element.classList.remove("error");
      }
      if (label2 == "" && element.tagName == "INPUT") {
        element.classList.add("error");
      }
    });
  });
  findInputArray.forEach((element) => {
    element.addEventListener("mouseover", () => {
      findInput.forEach((delClass) => {
      if (delClass.classList.contains("myElem")) {
        delClass.classList.remove("myElem");
      }
    });
  });
});

  getMyForm.children[6].addEventListener("click", (e) => {
    const label1 = findInput[0].value;
    const label2 = findInput[1].options.selectedIndex;
    if (label1 == "" || label2 == 0) {
      console.log("Заполните поля");
      findInput.forEach((element) => {
        element.classList.add("error", "myElem");
      });
      e.preventDefault();
    }
  });
  */
</script>
